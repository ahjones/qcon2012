* QCon
** Building highly available systems in Erlang
Joe Armstrong
*** The types of highly available systems
    How do you get ten nines availability? Why even ten? The number is
    arbitrary.

    - Washing machine / pacemaker (!)
      Very specialised, embedded. Processor and the data are in the
      same place, so easy to program.
    - Deep space mission
      The only things that'll be left of humans after we're gone (so far)
    - Aircraft control system
      Wait until the plane is on the ground before changing the
      software. Shut down the nuclear plant before updating the
      software.
    - Internet systems
      This talk. Data and processing separate and distributed.

*** Internet available systems
    Systems like this need highly available data.

    Computation can be performed anywhere.

    We want many routes to the data.

**** Where is my data?
     If there are 10 million computers and my data is on ten of them,
     I can't ask each computer if it has my data.

***** Algorithm: [[http://en.wikipedia.org/wiki/Chord_(peer-to-peer)][Chord]]
      + Hash the computers IPs
      + Sort the hashes
      + Hash the lookup key
      + Put the data on the first machine with a hash that's lower
        than the key's hash

**** How do I store replicas in a consistent way?
     Collect data in parallel. Save data in parallel.
     
     #+BEGIN_QUOTE
     The problem of reliable storage of data has been solved. -- Joe Armstrong
     #+END_QUOTE

*** The six properties of available systems
**** 1. Isolation
     Formal definition: "my program should not fuck up your program". 

**** 2. Concurrency
     Programming in sequential languages is difficult because the
     world isn't seequential.

     "Embarrassingly parallel" problems: web servers.

**** 3. Must be able to detect failure
     If you can't detect it, you can't fix it. This must work across
     machine boundaries. If a machine dies you can't tell if it's the
     machine or the network.

     If you make things synchronous you'll bugger things up.

**** 4. Fault identification
     It's not enough to know that there is a fault.

**** 5. Live code upgrade
     Wow. Why would you want to stop it? We want zero downtime. Early
     requirement for Erlang. At Ericsson you got told off if your
     system was down for more than four minutes in a year. That's ~
     five nines availability.

**** 6. Stable storage
     Suppose all computers crash: you want your data back.

*** Other thoughts
**** Jim Gray
     Fail fast: software should either function correctly or detect
     the fault, signal failure and stop operating.

     If you've got a single process you can't let it die. If you have
     millions of processes, you can let a few thousand die.

     See society: we wander around doing what we want, and if we fall
     down with a heart attack the ambulance rocks up and fixes
     you. Send in the medic.

     Have threads that detect the failure of other threads.

**** Messaging
     #+BEGIN_QUOTE
     The big idea is messaging. -- Alan Kay
     #+END_QUOTE
*** How to satisfy the properties in Erlang
    Use a programming language designed for it. Armstrong can only
    think of one. Ha ha.

    1. Isolation

       Isolate processes so that they can't damage one
       another. No shared memory, lightweight.

       Treating failure with shared memory is very difficult.

    2. Concurrency

       Run the processes in parallel. Hardware design will mean that
       soon we're able to run many processes concurrently.

       Erlang has network transparency so the processes might be
       running elsewhere.

    3. Failure detecting

       Erlang processes can detect failure. This is out of bound: not
       a normal message. It's a signal. It's messy if you handle
       failure in the same place that you handle normal stuff.
       
       Fix the failure somewhere else. What does failing A have to
       send running B so that B can carry on doing the job that A
       didn't manage.

    4. Fault identification

       Special processes that handle errors.

       #+BEGIN_SRC erlang
       receive
           {'EXIT', Pid, Why} ->
               error_log:log_error({erlang:now(), Pid, Why})
       end
       #+END_SRC

    5. Live code upgrade

       In Erlang you can modify code as it runs.

       #+BEGIN_SRC erlang

...
f1(X) ->
    foo:bar(X), % Call the latest version of this module
    bar(X). % Call this version of bar
       
bar(X) ->
    ...
       #+END_SRC

    6. Stable storage
       Use mnesia
       Use third party storage

**** Fault tolerance implies scalability
